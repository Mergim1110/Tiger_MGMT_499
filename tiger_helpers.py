# -*- coding: utf-8 -*-
"""tiger_helpers

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lyqs280zSaO_8WdkEgWKyGE6t32XORD9
"""

# ================================
# tiger_helpers.py  (single file)
# ================================

# --- Auto-install any missing dependencies (works inside .py) ---
import sys, subprocess
def _pip_install(pkg):
    try:
        subprocess.check_call([sys.executable, "-m", "pip", "install", pkg, "--quiet"])
    except Exception as e:
        print(f"[tiger_helpers] Failed to install {pkg}: {e}")

# pkg name -> import name
_needed = [
    ("pandas", "pandas"),
    ("numpy", "numpy"),
    ("matplotlib", "matplotlib"),
    ("statsmodels", "statsmodels"),
    ("linearmodels", "linearmodels"),
    ("seaborn", "seaborn"),
    ("plotly", "plotly"),
    ("geopandas", "geopandas"),
    ("pyogrio", "pyogrio"),
]

for pkg, mod in _needed:
    try:
        __import__(mod)
    except ImportError:
        _pip_install(pkg)

# Optional: set Plotly renderer (if present)
try:
    import plotly.io as _pio
    _pio.renderers.default = "colab"
except Exception:
    pass

# --- Imports (only what you already used) ---
import warnings, zipfile
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import statsmodels as _statsmodels  # keep namespace like your notebook
import statsmodels.api as sm
import plotly.express as px
import plotly.graph_objects as go
from scipy.interpolate import CubicSpline
from scipy.optimize import curve_fit
from linearmodels.panel import PanelOLS


# ---------- Data load ----------
def load_data():
    url = "https://raw.githubusercontent.com/Mergim1110/Tiger_MGMT_499/refs/heads/main/final_panel_with_green_indicator.csv"
    df = pd.read_csv(url, sep=",")
    return df


# ---------- Model 1 (Simple OLS) ----------
def model1_simple_ols(df):
    X = df[['heatwave_30_3d']]
    X = sm.add_constant(X)
    y = df['crime_rate']
    model = sm.OLS(y, X)
    results = model.fit()
    return results


# ---------- Maps (LAPD shapefile) ----------
def make_maps(df, shapefile_zip_path):
    import geopandas as gpd

    with zipfile.ZipFile(shapefile_zip_path, 'r') as zip_ref:
        zip_ref.extractall('/tmp/lapd_shapefile')
    districts_gdf = gpd.read_file('/tmp/lapd_shapefile')

    # District averages
    district_summary = df.groupby('district_id').agg({
        'heatwave_30_3d': 'mean',
        'crime_rate': 'mean'
    }).reset_index()

    # Merge on district_id
    districts_gdf['district_id'] = districts_gdf['PREC'].astype(int)
    districts_gdf = districts_gdf.merge(district_summary, on='district_id', how='left')

    print("\nMerged successfully!")
    cols = ['district_id', 'APREC', 'heatwave_30_3d', 'crime_rate']
    print(districts_gdf[cols].head())

    # Create maps
    fig, axes = plt.subplots(1, 2, figsize=(16, 8))

    districts_gdf.plot(column='heatwave_30_3d', ax=axes[0], cmap='YlOrRd',
                       legend=True, edgecolor='black', linewidth=0.5,
                       legend_kwds={'label': 'Heatwave Frequency', 'shrink': 0.8})
    axes[0].set_title('Heatwave Exposure by LAPD District (2020-2023)', fontsize=14, fontweight='bold')
    axes[0].axis('off')

    districts_gdf.plot(column='crime_rate', ax=axes[1], cmap='Reds',
                       legend=True, edgecolor='black', linewidth=0.5,
                       legend_kwds={'label': 'Domestic Violence Rate', 'shrink': 0.8})
    axes[1].set_title('Domestic Violence Rate by LAPD District (2020-2023)', fontsize=14, fontweight='bold')
    axes[1].axis('off')

    plt.tight_layout()
    plt.savefig('la_districts_maps.png', dpi=300, bbox_inches='tight')
    plt.show()
    print("\nMap saved as 'la_districts_maps.png'")


# ---------- Model 2 (Panel FE + controls) ----------
def model2_panel_fe(df):
    d = df.copy()
    d['date'] = pd.to_datetime(d['date'])
    panel = d.set_index(["district_id", "date"])
    y = panel["crime_rate"]
    X = panel[["heatwave_30_3d", "precip", "humidity_mean", "holiday"]].copy()
    X = X.join(pd.get_dummies(panel["dow"], prefix="dow", drop_first=True))
    X = X.join(pd.get_dummies(panel["month"], prefix="m", drop_first=True))
    X = X.join(pd.get_dummies(panel["year"], prefix="y", drop_first=True))
    mod = PanelOLS(y, X, entity_effects=True)
    res = mod.fit(cov_type="clustered", cluster_entity=True)
    return res


# ---------- Model 3 (Panel FE + greenness interaction) ----------
def model3_panel_green(df):
    d = df.copy()
    d['date'] = pd.to_datetime(d['date'])
    d['heatwave_green'] = d['heatwave_30_3d'] * d['green']
    panel = d.set_index(["district_id", "date"])
    y = panel["crime_rate"]
    X = panel[["heatwave_30_3d", "heatwave_green", "precip", "humidity_mean", "holiday"]].copy()
    X = X.join(pd.get_dummies(panel["dow"], prefix="dow", drop_first=True))
    X = X.join(pd.get_dummies(panel["month"], prefix="m", drop_first=True))
    X = X.join(pd.get_dummies(panel["year"], prefix="y", drop_first=True))
    mod = PanelOLS(y, X, entity_effects=True)
    res = mod.fit(cov_type="clustered", cluster_entity=True)
    return res


# ---------- Greenness β + CI visual (your logic) ----------
def _get_cov_df_from_res(result):
    # Try to obtain a labeled covariance matrix (robust) from linearmodels result
    candidates = []
    for name in ['cov', 'cov_params', 'covariance', '_cov']:
        if hasattr(result, name):
            obj = getattr(result, name)
            mat = obj() if callable(obj) else obj
            if mat is not None:
                candidates.append(mat)

    for mat in candidates:
        # Pandas object?
        if hasattr(mat, 'loc') and hasattr(mat, 'columns'):
            try:
                _ = mat.loc[result.params.index, result.params.index]
                return mat
            except Exception:
                pass
        # Numpy-like → wrap in DataFrame
        try:
            arr = np.asarray(mat)
            if arr.ndim == 2 and arr.shape[0] == arr.shape[1] == len(result.params):
                return pd.DataFrame(arr, index=result.params.index, columns=result.params.index)
        except Exception:
            pass

    # Fallback: diagonal from std errors
    se = np.asarray(result.std_errors)
    diag = np.diag(se**2)
    return pd.DataFrame(diag, index=result.params.index, columns=result.params.index)


def plot_greenness_ci(res, save_path='betas_ci_greenness_clean.png'):
    import matplotlib.patches as patches

    b1  = float(res.params['heatwave_30_3d'])         # Non-green beta
    bi  = float(res.params['heatwave_green'])         # Difference (green - non-green)
    se1 = float(res.std_errors['heatwave_30_3d'])
    sei = float(res.std_errors['heatwave_green'])

    cov_df = _get_cov_df_from_res(res)
    cov_b1_bi = float(cov_df.loc['heatwave_30_3d', 'heatwave_green'])

    # Non-green
    beta_ng = b1
    lo_ng   = beta_ng - 1.96*se1
    hi_ng   = beta_ng + 1.96*se1

    # Green = b1 + bi  (with correct variance via covariance)
    beta_g  = b1 + bi
    var_g   = se1**2 + sei**2 + 2*cov_b1_bi
    se_g    = float(np.sqrt(max(var_g, 0)))
    lo_g    = beta_g - 1.96*se_g
    hi_g    = beta_g + 1.96*se_g

    labels   = ['OLS: Non-green', 'OLS: Green']
    xpos     = [0, 1]
    width    = 0.6
    ci_cols  = ['#ADD8E6', '#F4A6A6']  # light blue/red

    fig, ax = plt.subplots(figsize=(10, 6))

    # CI boxes + coefficient lines
    vals = [(beta_ng, lo_ng, hi_ng), (beta_g, lo_g, hi_g)]
    for x, (b, lo, hi), col in zip(xpos, vals, ci_cols):
        rect = patches.Rectangle((x - width/2, lo), width, hi - lo,
                                 linewidth=0, facecolor=col, alpha=0.5)
        ax.add_patch(rect)
        ax.plot([x - width/2, x + width/2], [b, b], color='black', linewidth=4)

    # Axis cosmetics
    ax.set_xticks(xpos)
    ax.set_xticklabels(labels)
    ax.set_ylabel('Effect of heatwave on domestic violence (β)')
    ax.set_title('Coefficients and 95% Confidence Intervals\n(PanelOLS with entity and time FE, SE clustered)')

    ax.yaxis.grid(True, linestyle='--', alpha=0.35)
    ax.set_axisbelow(True)

    # Callouts above each CI
    def add_callout(x, b, lo, hi, edge_color):
        span = (max(hi_ng, hi_g) - min(lo_ng, lo_g)) + 1e-9
        y = hi + 0.05*span
        txt = f"β = {b:.4f}\n95% CI: [{lo:.4f}, {hi:.4f}]"
        ax.annotate(txt, xy=(x, y), ha='center', va='bottom', fontsize=10,
                    bbox=dict(facecolor='white', edgecolor=edge_color, boxstyle='round,pad=0.3', alpha=0.95))

    add_callout(xpos[0], beta_ng, lo_ng, hi_ng, '#6AAED6')
    add_callout(xpos[1], beta_g,  lo_g,  hi_g,  '#E28C8C')

    # Legend
    legend_handles = [
        patches.Patch(facecolor=ci_cols[0], alpha=0.5, label='Non-green: 95% CI'),
        patches.Patch(facecolor=ci_cols[1], alpha=0.5, label='Green: 95% CI'),
    ]
    ax.legend(handles=legend_handles, loc='upper left', bbox_to_anchor=(1.01, 1), borderaxespad=0.)

    plt.tight_layout()
    plt.savefig(save_path, dpi=300, bbox_inches='tight')
    plt.show()


# ---------- Appendix: OLS table (aligned ASCII) ----------
def ols_table(df):
    import pandas as pd
    from linearmodels.panel import PanelOLS
    import statsmodels.api as sm

    d = df.copy()
    d['date'] = pd.to_datetime(d['date'])

    # Model 1: Simple OLS
    X1 = sm.add_constant(d[['heatwave_30_3d']]); y1 = d['crime_rate']
    res1 = sm.OLS(y1, X1).fit()

    # Model 2: Panel FE + controls
    p  = d.set_index(["district_id", "date"])
    y2 = p["crime_rate"]
    X2 = p[["heatwave_30_3d","precip","humidity_mean","holiday"]].copy()
    X2 = X2.join(pd.get_dummies(p["dow"],   prefix="dow", drop_first=True))
    X2 = X2.join(pd.get_dummies(p["month"], prefix="m",   drop_first=True))
    X2 = X2.join(pd.get_dummies(p["year"],  prefix="y",   drop_first=True))
    res2 = PanelOLS(y2, X2, entity_effects=True).fit(cov_type="clustered", cluster_entity=True)

    # Model 3: Panel FE + greenness interaction
    d['heatwave_green'] = d['heatwave_30_3d'] * d['green']
    p  = d.set_index(["district_id", "date"])
    y3 = p["crime_rate"]
    X3 = p[["heatwave_30_3d","heatwave_green","precip","humidity_mean","holiday"]].copy()
    X3 = X3.join(pd.get_dummies(p["dow"],   prefix="dow", drop_first=True))
    X3 = X3.join(pd.get_dummies(p["month"], prefix="m",   drop_first=True))
    X3 = X3.join(pd.get_dummies(p["year"],  prefix="y",   drop_first=True))
    res3 = PanelOLS(y3, X3, entity_effects=True).fit(cov_type="clustered", cluster_entity=True)

    def stars(p):
        return '***' if p < 0.001 else '**' if p < 0.01 else '*' if p < 0.05 else ''

    # Fixed widths (ASCII only to avoid width glitches)
    VAR_W = 26
    COL_W = 18

    def fmt_var(s):  return str(s).ljust(VAR_W)
    def fmt_col(s):  return str(s).rjust(COL_W)
    def fmt_coef(val, p): return f"{val:.4f}{stars(p)}"
    def fmt_se(se):       return f"({se:.4f})"

    width_total = VAR_W + 3*COL_W + 3
    line = "-" * width_total

    print("\n" + "=" * width_total)
    print("Dependent Variable: Domestic Violence Rate".center(width_total))
    print("=" * width_total)
    print(
        fmt_var("Variable") + " " +
        fmt_col("(1)") + " " +
        fmt_col("(2)") + " " +
        fmt_col("(3)")
    )
    print(
        fmt_var("") + " " +
        fmt_col("Simple OLS") + " " +
        fmt_col("FE + Controls") + " " +
        fmt_col("With Greenness")
    )
    print(line)

    # Intercept (only model 1)
    print(
        fmt_var("Intercept") + " " +
        fmt_col(fmt_coef(res1.params['const'], res1.pvalues['const'])) + " " +
        fmt_col("") + " " +
        fmt_col("")
    )
    print(
        fmt_var("") + " " +
        fmt_col(fmt_se(res1.bse['const'])) + " " +
        fmt_col("") + " " +
        fmt_col("")
    )

    # Heatwave
    print(
        fmt_var("Heatwave (30C, 3d)") + " " +
        fmt_col(fmt_coef(res1.params['heatwave_30_3d'], res1.pvalues['heatwave_30_3d'])) + " " +
        fmt_col(fmt_coef(res2.params['heatwave_30_3d'], res2.pvalues['heatwave_30_3d'])) + " " +
        fmt_col(fmt_coef(res3.params['heatwave_30_3d'], res3.pvalues['heatwave_30_3d']))
    )
    print(
        fmt_var("") + " " +
        fmt_col(fmt_se(res1.bse['heatwave_30_3d'])) + " " +
        fmt_col(fmt_se(res2.std_errors['heatwave_30_3d'])) + " " +
        fmt_col(fmt_se(res3.std_errors['heatwave_30_3d']))
    )

    # Precipitation
    print(
        fmt_var("Precipitation") + " " +
        fmt_col("") + " " +
        fmt_col(fmt_coef(res2.params['precip'], res2.pvalues['precip'])) + " " +
        fmt_col(fmt_coef(res3.params['precip'], res3.pvalues['precip']))
    )
    print(
        fmt_var("") + " " +
        fmt_col("") + " " +
        fmt_col(fmt_se(res2.std_errors['precip'])) + " " +
        fmt_col(fmt_se(res3.std_errors['precip']))
    )

    # Humidity
    print(
        fmt_var("Humidity") + " " +
        fmt_col("") + " " +
        fmt_col(fmt_coef(res2.params['humidity_mean'], res2.pvalues['humidity_mean'])) + " " +
        fmt_col(fmt_coef(res3.params['humidity_mean'], res3.pvalues['humidity_mean']))
    )
    print(
        fmt_var("") + " " +
        fmt_col("") + " " +
        fmt_col(fmt_se(res2.std_errors['humidity_mean'])) + " " +
        fmt_col(fmt_se(res3.std_errors['humidity_mean']))
    )

    # Holiday
    print(
        fmt_var("Holiday") + " " +
        fmt_col("") + " " +
        fmt_col(fmt_coef(res2.params['holiday'], res2.pvalues['holiday'])) + " " +
        fmt_col(fmt_coef(res3.params['holiday'], res3.pvalues['holiday']))
    )
    print(
        fmt_var("") + " " +
        fmt_col("") + " " +
        fmt_col(fmt_se(res2.std_errors['holiday'])) + " " +
        fmt_col(fmt_se(res3.std_errors['holiday']))
    )

    # Interaction
    print(
        fmt_var("Heatwave x Green") + " " +
        fmt_col("") + " " +
        fmt_col("") + " " +
        fmt_col(fmt_coef(res3.params['heatwave_green'], res3.pvalues['heatwave_green']))
    )
    print(
        fmt_var("") + " " +
        fmt_col("") + " " +
        fmt_col("") + " " +
        fmt_col(fmt_se(res3.std_errors['heatwave_green']))
    )

    print(line)
    print(
        fmt_var("Observations") + " " +
        fmt_col(f"{int(res1.nobs):,}") + " " +
        fmt_col(f"{int(res2.nobs):,}") + " " +
        fmt_col(f"{int(res3.nobs):,}")
    )
    print(
        fmt_var("R^2 (within for FE)") + " " +
        fmt_col(f"{res1.rsquared:.3f}") + " " +
        fmt_col(f"{res2.rsquared_within:.3f}") + " " +
        fmt_col(f"{res3.rsquared_within:.3f}")
    )
    print(
        fmt_var("District FE") + " " +
        fmt_col("No") + " " +
        fmt_col("Yes") + " " +
        fmt_col("Yes")
    )
    print(
        fmt_var("Time FE (dow, m, y)") + " " +
        fmt_col("No") + " " +
        fmt_col("Yes") + " " +
        fmt_col("Yes")
    )
    print("=" * width_total)


# ---------- Correlation matrix + VIF ----------
def corr_and_vif(df, heatmap_path='correlation_matrix.png'):
    import seaborn as sns
    from statsmodels.stats.outliers_influence import variance_inflation_factor

    vars_to_check = ['heatwave_30_3d', 'precip', 'humidity_mean', 'holiday', 'green']

    # Correlation matrix
    corr_matrix = df[vars_to_check].corr()
    plt.figure(figsize=(8, 6))
    sns.heatmap(corr_matrix, annot=True, fmt='.3f', cmap='coolwarm',
                center=0, square=True, linewidths=1, cbar_kws={"shrink": 0.8})
    plt.title('Correlation Matrix: Key Variables', fontsize=14, fontweight='bold')
    plt.tight_layout()
    plt.savefig(heatmap_path, dpi=300, bbox_inches='tight')
    plt.show()

    # VIF
    vif_data = df[vars_to_check].dropna()
    vif_results = pd.DataFrame()
    vif_results["Variable"] = vars_to_check
    vif_results["VIF"] = [variance_inflation_factor(vif_data.values, i) for i in range(len(vars_to_check))]

    print("\n" + "="*50)
    print("Variance Inflation Factor (VIF) Test")
    print("="*50)
    print(vif_results)
    print("\nInterpretation:")
    print("VIF < 5: No multicollinearity concern")
    print("VIF 5-10: Moderate multicollinearity")
    print("VIF > 10: High multicollinearity (problematic)")

    return vif_results